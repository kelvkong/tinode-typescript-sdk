import { log, makeBaseUrl, NetworkProviders, jsonParseHelper } from './utilities';
import { AppSettings, XDRStatus } from './constants';
import { Subject } from 'rxjs';

export type Transport = 'ws' | 'wss' | 'lp';
export interface AutoReconnectData {
    timeout: number;
    promise?: Promise<any>;
}
export interface OnDisconnetData {
    error: Error;
    code: number;
}

/**
 * An abstraction for a websocket or a long polling connection.
 */
export class Connection {
    private host = '';
    private apiKey = '';
    private secure = false;
    private transport: Transport;
    private autoReconnect = false;

    /**
     * Settings for exponential backoff
     * 2000 milliseconds, minimum delay between reconnects
     */
    private BOFF_BASE = 2000;
    /**
     * Settings for exponential backoff
     * Maximum delay between reconnects 2^10 * 2000 ~ 34 minutes
     */
    private BOFF_MAX_ITER = 10;
    /**
     * Settings for exponential backoff
     * Add random delay
     */
    private BOFF_JITTER = 0.3;

    private boffTimer = null;
    private boffIteration = 0;
    /**
     *  Indicator if the socket was manually closed - don't autoReconnect if true.
     */
    private boffClosed = false;
    private socket = null;
    private sender = null;
    private poller = null;
    private lpURL = null;

    // Events
    onOpen = new Subject<void>();
    onMessage = new Subject<any>();
    onDisconnect = new Subject<OnDisconnetData>();
    onAutoReconnectIteration = new Subject<AutoReconnectData>();

    /**
     * @param host - Host name and port number to connect to.
     * @param apiKey - API key generated by keygen
     * @param transport - Network transport to use, either `ws`/`wss` for websocket or `lp` for long polling.
     * @param secure - Use secure WebSocket (wss) if true.
     * @param autoReconnect - If connection is lost, try to reconnect automatically.
     */
    constructor(host: string, apiKey: string, transport: Transport, secure: boolean, autoReconnect: boolean) {
        this.host = host;
        this.apiKey = apiKey;
        this.secure = secure;
        this.transport = transport;
        this.autoReconnect = autoReconnect;
    }

    /**
     * Terminate auto-reconnect process.
     */
    private boffStop() {
        clearTimeout(this.boffTimer);
        this.boffTimer = 0;
    }

    /**
     * Reset auto-reconnect iteration counter.
     */
    private boffReset() {
        this.boffIteration = 0;
    }

    /**
     * Backoff implementation - reconnect after a timeout.
     */
    boffReconnect(): void {
        // Clear timer
        clearTimeout(this.boffTimer);
        // Calculate when to fire the reconnect attempt
        const timeout = this.BOFF_BASE * (Math.pow(2, this.boffIteration) * (1.0 + this.BOFF_JITTER * Math.random()));
        // Update iteration counter for future use
        if (this.boffIteration < this.BOFF_MAX_ITER) {
            this.boffIteration = this.boffIteration + 1;
        }
        this.onAutoReconnectIteration.next({ timeout });

        this.boffTimer = setTimeout(() => {
            log('Reconnecting, iter=' + this.boffIteration + ', timeout=' + timeout);
            // Maybe the socket was closed while we waited for the timer?
            if (!this.boffClosed) {
                const prom = this.connect();
                this.onAutoReconnectIteration.next({ timeout: 0, promise: prom });
            } else {
                this.onAutoReconnectIteration.next({ timeout: -1 });
            }
        }, timeout);
    }

    /**
     * Initiate a new connection
     * @param host - Host name to connect to; if null the old host name will be used.
     * @param force - Force new connection even if one already exists.
     */
    connect(host?: string, force?: boolean): Promise<any> {
        if (this.transport === 'ws' || this.transport === 'wss') {
            return this.connectWs(host, force);
        }
        if (this.transport === 'lp') {
            return this.connectLp(host, force);
        }
    }

    /**
     * Initiate a new connection
     * Returns Promise resolved/rejected when the connection call completes, resolution is called without parameters,
     * rejection passes the {Error} as parameter.
     * @param host - Host name to connect to; if null the old host name will be used.
     * @param force - Force new connection even if one already exists.
     */
    private connectWs(host: string, force: boolean): Promise<any> {
        this.boffClosed = false;

        if (this.socket) {
            if (!force && this.socket.readyState === this.socket.OPEN) {
                return Promise.resolve();
            }
            this.socket.close();
            this.socket = null;
        }

        if (host) {
            this.host = host;
        }

        return new Promise((resolve, reject) => {
            const url = makeBaseUrl(this.host, this.secure ? 'wss' : 'ws', this.apiKey);
            log('Connecting to: ', url);
            const conn = new NetworkProviders.WebSocket(url);

            conn.onerror = (err) => {
                reject(err);
            };

            conn.onopen = (() => {
                if (this.autoReconnect) {
                    this.boffStop();
                }
                this.onOpen.next();
                resolve();
            }).bind(this);

            conn.onclose = (() => {
                this.socket = null;
                const code = this.boffClosed ? AppSettings.NETWORK_USER : AppSettings.NETWORK_ERROR;
                const error = new Error(this.boffClosed ? AppSettings.NETWORK_USER_TEXT : AppSettings.ERROR_TEXT + ' (' + code + ')');
                this.onDisconnect.next({ error, code });
                if (!this.boffClosed && this.autoReconnect) {
                    this.boffReconnect();
                }
            }).bind(this);

            conn.onmessage = ((evt: any) => {
                this.onMessage.next(evt.data);
            }).bind(this);
            this.socket = conn;
        });
    }

    /**
     * Initiate long polling connection connection
     * @param host - Host name to connect to; if null the old host name will be used.
     * @param force - Force new connection even if one already exists.
     */
    private connectLp(host: string, force: boolean): Promise<any> {
        this.boffClosed = false;

        if (this.poller) {
            if (!force) {
                return Promise.resolve();
            }
            this.poller.onreadystatechange = undefined;
            this.poller.abort();
            this.poller = null;
        }

        if (host) {
            this.host = host;
        }

        return new Promise((resolve, reject) => {
            const url = makeBaseUrl(this.host, this.secure ? 'https' : 'http', this.apiKey);
            log('Connecting to: ', url);
            this.poller = this.lpPoller(url, resolve, reject);
            this.poller.send(null);
        }).catch((err) => {
            console.log('LP connection failed:', err);
        });
    }

    private lpPoller(url: string, resolve?: any, reject?: any) {
        let poller = new NetworkProviders.XMLHTTPRequest();
        let promiseCompleted = false;

        poller.onreadystatechange = ((evt: any) => {
            if (poller.readyState === XDRStatus.DONE) {
                if (poller.status === 201) { // 201 == HTTP.Created, get SID
                    const pkt = JSON.parse(poller.responseText, jsonParseHelper);
                    this.lpURL = url + '&sid=' + pkt.ctrl.params.sid;
                    poller = this.lpPoller(this.lpURL);
                    poller.send(null);
                    this.onOpen.next();

                    if (resolve) {
                        promiseCompleted = true;
                        resolve();
                    }

                    if (this.autoReconnect) {
                        this.boffStop();
                    }
                }
            } else if (poller.status < 400) { // 400 = HTTP.BadRequest
                this.onMessage.next(poller.responseText);
                this.poller = this.lpPoller(this.lpURL);
                this.poller.send(null);
            } else {
                // Don't throw an error here, gracefully handle server errors
                if (reject && !promiseCompleted) {
                    promiseCompleted = true;
                    reject(poller.responseText);
                }

                if (poller.responseText) {
                    this.onMessage.next(poller.responseText);
                }

                const code = poller.status || (this.boffClosed ? AppSettings.NETWORK_USER : AppSettings.NETWORK_ERROR);
                const text = poller.responseText || (this.boffClosed ? AppSettings.NETWORK_USER_TEXT : AppSettings.ERROR_TEXT);
                this.onDisconnect.next({ error: new Error(text + ' (' + code + ')'), code });

                // Polling has stopped. Indicate it by setting poller to null.
                poller = null;
                if (!this.boffClosed && this.autoReconnect) {
                    this.boffReconnect();
                }
            }
        }).bind(this);

        poller.open('GET', this.lpURL, true);
        return poller;
    }

    reconnect(force: boolean) {
        this.boffStop();
        this.connect(null, force);
    }

    disconnect() {
        if (this.transport === 'ws' || this.transport === 'wss') {
            this.disconnectWs();
        }
        if (this.transport === 'lp') {
            this.disconnectLp();
        }
    }

    private disconnectWs() {
        this.boffClosed = true;
        if (!this.socket) {
            return;
        }

        this.boffStop();
        this.socket.close();
        this.socket = null;
    }

    private disconnectLp() {
        this.boffClosed = true;
        this.boffStop();

        if (this.sender) {
            this.sender.onreadystatechange = undefined;
            this.sender.abort();
            this.sender = null;
        }
        if (this.poller) {
            this.poller.onreadystatechange = undefined;
            this.poller.abort();
            this.poller = null;
        }

        const error = new Error(AppSettings.NETWORK_USER_TEXT + ' (' + AppSettings.NETWORK_USER + ')');
        this.onDisconnect.next({ error, code: AppSettings.NETWORK_USER });
        // Ensure it's reconstructed
        this.lpURL = null;
    }
}
