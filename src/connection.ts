import { Subject } from 'rxjs';
import { log } from './utilities';

export type Transport = 'ws' | 'wss' | 'lp';
export interface AutoReconnectData {
    timeout: number;
    promise?: Promise<any>;
}

/**
 * An abstraction for a websocket or a long polling connection.
 */
export class Connection {
    private host = '';
    private apiKey = '';
    private secure = false;
    private transport: Transport;
    private autoReconnect = false;

    /**
     * Settings for exponential backoff
     * 2000 milliseconds, minimum delay between reconnects
     */
    private BOFF_BASE = 2000;
    /**
     * Settings for exponential backoff
     * Maximum delay between reconnects 2^10 * 2000 ~ 34 minutes
     */
    private BOFF_MAX_ITER = 10;
    /**
     * Settings for exponential backoff
     * Add random delay
     */
    private BOFF_JITTER = 0.3;

    private boffTimer = null;
    private boffIteration = 0;
    /**
     *  Indicator if the socket was manually closed - don't autoReconnect if true.
     */
    private boffClosed = false;

    // Events
    onAutoReconnectIteration = new Subject<AutoReconnectData>();

    /**
     * @param host - Host name and port number to connect to.
     * @param apiKey - API key generated by keygen
     * @param transport - Network transport to use, either `ws`/`wss` for websocket or `lp` for long polling.
     * @param secure - Use secure WebSocket (wss) if true.
     * @param autoReconnect - If connection is lost, try to reconnect automatically.
     */
    constructor(host: string, apiKey: string, transport: Transport, secure: boolean, autoReconnect: boolean) {
        this.host = host;
        this.apiKey = apiKey;
        this.secure = secure;
        this.transport = transport;
        this.autoReconnect = autoReconnect;
    }

    /**
     * Backoff implementation - reconnect after a timeout.
     */
    boffReconnect(): void {
        // Clear timer
        clearTimeout(this.boffTimer);
        // Calculate when to fire the reconnect attempt
        const timeout = this.BOFF_BASE * (Math.pow(2, this.boffIteration) * (1.0 + this.BOFF_JITTER * Math.random()));
        // Update iteration counter for future use
        if (this.boffIteration < this.BOFF_MAX_ITER) {
            this.boffIteration = this.boffIteration + 1;
        }
        this.onAutoReconnectIteration.next({ timeout });

        this.boffTimer = setTimeout(() => {
            log('Reconnecting, iter=' + this.boffIteration + ', timeout=' + timeout);
            // Maybe the socket was closed while we waited for the timer?
            if (!this.boffClosed) {
                const prom = this.connect();
                this.onAutoReconnectIteration.next({ timeout: 0, promise: prom });
            } else {
                this.onAutoReconnectIteration.next({ timeout: -1 });
            }
        }, timeout);
    }

    connect(): any {
        // TODO: implement
    }
}
